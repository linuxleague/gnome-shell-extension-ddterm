#!/usr/bin/env gjs

/*
    Copyright Â© 2023 Aleksandr Mezin

    This file is part of ddterm GNOME Shell extension.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

'use strict';

const System = imports.system;

const { GObject, Gio } = imports.gi;

const CODEGEN_DIR = Gio.File.new_for_commandline_arg(System.programInvocationName).get_parent();
const ROOT_DIR = CODEGEN_DIR.get_parent().get_parent().get_parent();

imports.searchPath.unshift(
    ROOT_DIR.get_child('ddterm').get_child('app').get_child('fakeext').get_path()
);

imports.misc.init(ROOT_DIR);

const schema = imports.ddterm.settings.schema.getSchema();

const indent = '    ';

function repr_paramflags(flags) {
    const result = [];

    if ((flags & GObject.ParamFlags.READWRITE) === GObject.ParamFlags.READWRITE) {
        result.push('GObject.ParamFlags.READWRITE');
        flags &= ~GObject.ParamFlags.READWRITE;
    }

    if (flags & GObject.ParamFlags.READABLE)
        result.push('GObject.ParamFlags.READABLE');

    if (flags & GObject.ParamFlags.WRITABLE)
        result.push('GObject.ParamFlags.WRITABLE');

    if (flags & GObject.ParamFlags.CONSTRUCT)
        result.push('GObject.ParamFlags.CONSTRUCT');

    if (flags & GObject.ParamFlags.CONSTRUCT_ONLY)
        result.push('GObject.ParamFlags.CONSTRUCT_ONLY');

    if (flags & GObject.ParamFlags.EXPLICIT_NOTIFY)
        result.push('GObject.ParamFlags.EXPLICIT_NOTIFY');

    return result.join(' | ');
}

function emit_pspec(pspec_type, name, ...args) {
    print(`${indent}${JSON.stringify(name)}: ${pspec_type}(`);

    for (const arg of [name, name, name])
        print(`${indent}${indent}${JSON.stringify(arg)},`);

    for (const arg of args)
        print(`${indent}${indent}${arg},`);

    print(`${indent}),`);
}

function emit_pspec_range(pspec_type, name, flags, minimum, maximum, default_value) {
    emit_pspec(
        pspec_type,
        name,
        repr_paramflags(flags),
        JSON.stringify(minimum),
        JSON.stringify(maximum),
        JSON.stringify(default_value)
    );
}

function emit_pspec_type(pspec_type, name, flags, type) {
    emit_pspec(
        pspec_type,
        name,
        repr_paramflags(flags),
        type
    );
}

function emit_pspec_default(pspec_type, name, flags, default_value) {
    emit_pspec(
        pspec_type,
        name,
        repr_paramflags(flags),
        JSON.stringify(default_value)
    );
}

function emit_pspec_variant(name, flags, type_string, default_value = null) {
    emit_pspec(
        'GObject.param_spec_variant',
        name,
        `new GLib.VariantType(${JSON.stringify(type_string)})`,
        default_value === null
            ? 'null'
            : `new GLib.Variant(${JSON.stringify(type_string)}, ${JSON.stringify(default_value)})`,
        repr_paramflags(flags)
    );
}

const primitive_pspecs = {
    'b': 'GObject.ParamSpec.boolean',
    'y': 'GObject.ParamSpec.uint',
    'n': 'GObject.ParamSpec.int',
    'q': 'GObject.ParamSpec.uint',
    'i': 'GObject.ParamSpec.int',
    'u': 'GObject.ParamSpec.uint',
    'x': 'GObject.ParamSpec.int64',
    't': 'GObject.ParamSpec.uint64',
    'd': 'GObject.ParamSpec.double',
    's': 'GObject.ParamSpec.string',
};

print('/* Autogenerated from settings schema */');
print("'use strict';");
print('/* eslint-disable comma-dangle, quotes, max-len */');
print('const { GLib, GObject } = imports.gi;');
print('const TYPE_STRV = GLib.strv_get_type();');
print('var PSPECS = {');

for (const name of schema.list_keys().sort()) {
    const key = schema.get_key(name);
    const type_string = key.get_value_type().dup_string();

    if (type_string === 'as') {
        emit_pspec_type(
            'GObject.ParamSpec.boxed',
            name,
            GObject.ParamFlags.READWRITE | GObject.ParamFlags.EXPLICIT_NOTIFY,
            'TYPE_STRV'
        );

        continue;
    }

    const pspec_type = primitive_pspecs[type_string];
    const default_value = key.get_default_value().unpack();
    if (!pspec_type) {
        emit_pspec_variant(
            name,
            GObject.ParamFlags.READWRITE | GObject.ParamFlags.EXPLICIT_NOTIFY,
            type_string,
            default_value
        );

        continue;
    }

    const [range_type, range] = key.get_range().deepUnpack();
    if (range_type === 'range') {
        const [min, max] = range.deepUnpack();

        emit_pspec_range(
            pspec_type,
            name,
            GObject.ParamFlags.READWRITE | GObject.ParamFlags.EXPLICIT_NOTIFY,
            min,
            max,
            default_value
        );

        continue;
    }

    emit_pspec_default(
        pspec_type,
        name,
        GObject.ParamFlags.READWRITE | GObject.ParamFlags.EXPLICIT_NOTIFY,
        default_value
    );
}

print('};');
print('/* exported PSPECS */');
